# (C) Modulos AG (2019-2022). You may use and modify this code according
# to the Modulos AG Terms and Conditions. Please retain this header.
"""Utility function for the time series node generation."""
import numpy as np
from typing import Dict, List, Tuple


GENERATED_NODES_SUFFIX = "__shifted_t"
MULTI_OUTPUT_LABEL_SUFFIX = "__multi_step_output_vector"


def get_generated_node_name(original_name: str, time_step: int) -> str:
    """This function returns the name of the node that is generated from a
    certain original node with a certain shift.

    Args:
        original_name (str): Name of the original node.
        time_step (int): Shift (positive or negative) of the generated node.
            e.g. -3 means t-3 or 2 means t+2.

    Returns:
        str: Name of the generated (shifted) node.
    """
    if time_step == 0:
        return original_name
    elif time_step > 0:
        return f"{original_name}{GENERATED_NODES_SUFFIX}+{time_step}"
    else:
        return f"{original_name}{GENERATED_NODES_SUFFIX}{time_step}"


def get_mimo_vector_node_name(original_name: str) -> str:
    """This function computes the name of the generated MIMO label vector node.

    Args:
        original_name (str): Name of the original node.

    Returns:
        str: Name of the generated node.
    """
    return f"{original_name}{MULTI_OUTPUT_LABEL_SUFFIX}"


def get_original_node_name(generated_node_name: str) -> str:
    """This function returns the original node name of a generated time
    series node.

    Args:
        generated_node_name (str): Name of the original node.

    Returns:
        str: Name of the original name.
    """
    if GENERATED_NODES_SUFFIX in generated_node_name:
        return generated_node_name.split(GENERATED_NODES_SUFFIX)[0]
    elif MULTI_OUTPUT_LABEL_SUFFIX in generated_node_name:
        return generated_node_name.split(MULTI_OUTPUT_LABEL_SUFFIX)[0]
    else:
        return generated_node_name


def is_node_generated_by_window_sliding(node_name: str) -> bool:
    """Check whether a given node name belongs to a node generated by window
    sliding.

    Args:
        node_name (str): Node name to check.

    Returns:
        bool: True if it is a generated node and False otherwise.
    """
    return GENERATED_NODES_SUFFIX in node_name


def get_time_step_of_generated_node(node_name: str) -> int:
    """Get the time step of a generated node by its name. The node cannot
    be the name of the multi-step label.

    Args:
        node_name (str): Node name of the generated node.

    Returns:
        int: Time step of the generated node.

    Raises:
        ValueError, if the node is not generated by window sliding.
        ValueError, if the node is a multi-step forecasting label.
    """
    if not is_node_generated_by_window_sliding(node_name):
        raise ValueError("This node was not generated by window sliding.")
    elif is_label_multi_output(node_name):
        raise ValueError("This function can only be applied to generated "
                         "window sliding nodes that are not a multi-step "
                         "forecasting label.")
    time_shift = int(node_name.split(GENERATED_NODES_SUFFIX)[1])
    return time_shift


def is_label_multi_output(node_name: str) -> bool:
    """Checks if the nodename is the label of a multi output timeseries
    workflow.

    Args:
        node_name (str): Name of the node.

    Returns:
        bool: True if it is the label of a multi output timeseries.
    """
    return MULTI_OUTPUT_LABEL_SUFFIX in node_name


def compute_new_nr_nodes(
        nr_nodes_original: int,
        feature_time_points: Dict[str, List[int]]) -> int:
    """
    Compute the number of nodes of the output dataset of the window sliding
    module.

    Args:
        nr_nodes_original (int): Number of nodes of the original dataset.
        feature_time_points (Dict[str, List[int]]): This is the argument
            `feature_time_points` of the function `slide_window`. It is
            just passed down to this function.

    Returns:
        int: Number nodes of the output dataset.
    """
    new_nr_nodes = nr_nodes_original - len(feature_time_points.keys())

    for time_points in feature_time_points.values():
        time_points_unique = list(set(time_points))
        new_nr_nodes += len(time_points_unique)
    return new_nr_nodes


def compute_new_nr_samples(
        nr_samples_original: int,
        feature_time_points: Dict[str, List[int]]) \
        -> Tuple[int, int]:
    """This function computes the number of samples that the output of the
    function `slide_window` will have.

    Args:
        nr_samples_original (int): Number of samples of the original
            dataset.
        feature_time_points (Dict[str, List[int]]): This is the argument
            `feature_time_points` of the function `slide_window`. It is
            just passed down to this function.

    Returns:
        Tuple[int, int]: Two integers. The first integer is the number of
            samples of the output dataset and the second integer is the
            first sample index of the original dataset that can be used.
            Note that we have to drop samples because the shifting would
            produce NaNs otherwise. Example: If we generate a new node
            `temperature_t-1`, that contains for each time step `t` the
            value of the node `temperature` at time step `t-1`, then
            we cannot use the first sample, because `t-1` does not exist.
    """
    negative_shifts = []
    positive_shifts = []
    for shifts in feature_time_points.values():
        for shift in shifts:
            if shift > 0:
                positive_shifts.append(shift)
            else:
                negative_shifts.append(shift)
    max_abs_negative_shift = np.max(np.abs(negative_shifts)) \
        if len(negative_shifts) > 0 else 0
    max_positive_shift = np.max(positive_shifts) \
        if len(positive_shifts) > 0 else 0
    new_nr_samples = nr_samples_original - max_abs_negative_shift \
        - max_positive_shift
    index_of_first_sample = max_abs_negative_shift
    # Convert to int, to make sure the values are json serializable (no
    # np.int64).
    return int(new_nr_samples), int(index_of_first_sample)


def get_nr_samples_dropped(
        nr_samples_input: int,
        feature_time_points: Dict[str, List[int]]) -> int:
    """Compute the number of samples that are dropped by the window sliding
    with the given settings.

    Args:
        nr_samples_input (int): Number of samples of the dataset that is given
            as input to the window sliding module.
        feature_time_points (Dict[str, List[int]]): The time points for
            different features. This equivalent to the window sliding config
            dict.

    Returns:
        int: Number os samples that are dropped by the window sliding.
    """
    nr_samples_output, _ = compute_new_nr_samples(
        nr_samples_input, feature_time_points)
    return nr_samples_input - nr_samples_output


def get_minimum_number_of_samples(
        feature_time_points: Dict[str, List[int]]) -> int:
    """Get the minimum number of samples that a dataset must have in order
    to pass the window sliding without failure.

    Args:
        feature_time_points (Dict[str, List[int]]): [description]

    Returns:
        int: Minimum number of samples for a successful window sliding run.
    """
    negative_shifts = []
    positive_shifts = []
    for shifts in feature_time_points.values():
        for shift in shifts:
            if shift > 0:
                positive_shifts.append(shift)
            else:
                negative_shifts.append(shift)
    max_abs_negative_shift = np.max(np.abs(negative_shifts)) \
        if len(negative_shifts) > 0 else 0
    max_positive_shift = np.max(positive_shifts) \
        if len(positive_shifts) > 0 else 0

    # We need to add 1 because we need the time step t, for which the shift
    # is 0.
    return max_abs_negative_shift + max_positive_shift + 1


def get_mimo_label_components(
        feature_time_points: Dict[str, List[int]],
        forecast_step: int) -> List[str]:
    """Get the names of the generated window sliding nodes that belong
    to a MIMO (Multiple Input Multiple Output) label, i.e. are components
    of the label vector. If there is only one positively shifted node,
    and the forecast step is > 0, then this function returns an empty list
    because the label is not part of a MIMO vector, but a scalar
    forecasting label.

    Example: If we generate t-2, t-1, t+1, t+2, t+3 for our target node
                `cnt`, and our forecast step is 1, it means that t+1, t+2,
                and t+3 belong to our label. In the MIMO strategy of
                multi step forecasting, we want to construct a label vector
                (t+1, t+2, t+3) for each sample. This function returns the
                node names of the sub-nodes that are put into this label
                vector, i.e. in our example it returns the list
                [cnt__shifted_t+1, cnt__shifted_t+2, cnt__shifted_t+3]

    Args:
        feature_time_points (Dict[str, List[int]]): This is the argument
            `feature_time_points` of the function `slide_window`. It is
            just passed down to this function.
        forecast_step (int): Forecast step of the time series workflow.

    Returns:
        str: Name of the target node, as it is used in the feature time
            steps dictionary.
    """
    mimo_labels = [
        f for f, time_steps in feature_time_points.items()
        if sum(1 for t in time_steps if t >= 0) > 1]
    if len(mimo_labels) > 1:
        raise ValueError(
            "There can only be one node with positive time steps.")
    elif len(mimo_labels) == 0:
        return []
    target_node = mimo_labels[0]
    target_node_time_steps = feature_time_points[target_node]
    time_steps_to_include = [t for t in target_node_time_steps if t >= 0]
    if 0 in time_steps_to_include and forecast_step > 0:
        time_steps_to_include.remove(0)
    if len(time_steps_to_include) < 2:
        return []
    else:
        return [get_generated_node_name(target_node, t)
                for t in time_steps_to_include]
